---
layout: post
title: Lezione #4
date: 2016-11-03 00:16:00
categories: lesson
short_description: Comunicazione tra Arduino e PureData su Raspberry.
image_preview: assets/lezione_4.jpg
---
## LEZIONE 4
Obiettivo della lezione è capire come costruire un sistema in grado di collezionare dati provenienti dal mondo fisico ed elaborarli in tempo reale per produrre segnale audio reattivo; il tutto mantenendo le dimensioni del sistema il più contenute possibile e senza utilizzare un computer (o per lo meno non un computer inteso nel senso _tradizionale_ del termine).

Proveremo quindi ad interfacciare una scheda **Arduino UNO** ed un **Raspberry Pi v3 mod B**.

Il metodo di interfacciamento tra le schede che vedremo oggi si basa sulla comunicazione seriale tramite protocollo **USB**.
Su Arduino è in esecuzione uno sketch il cui compito è collezionare i dati dai diversi sensori e rivere al contempo segnali di _via libera_ e _stop_ da un secondo software, questa volta in esecuzione su Raspberry, pronto a ricevere ed elaborare tali dati.

Questo secondo software è **Puredata**, ideale per funzionare a bordo del Raspeberry, per l'elaborazione del segnale audio e per la comunicazione seriale con Arduino.

### fase 1 - installazione dell'IDE e dei driver per la scheda Arduino
Prima di tutto occorre installare l'IDE Arduino sul proprio Raspberry in modo da poter riconoscere e programmare la scheda direttamente. Per farlo apriremo una nuova istanza del terminale e useremo il tool `aptitude` con il seguente comando:

```
sudo apt-get install arduino
```

L'applicativo IDE comparirà sotto la voce _Electronics_ del menù principale.

### fase 2 - installazione di PureData (e dell'oggetto [comport]) su Raspberry
A seguire occorre installare _PureData_ su Raspberry: `aptitute` ci torna nuovamente in aiuto:

```
sudo apt-get install puredata
```

Basta seguire le eventuali istruzioni a schermo per installare tutti i pacchetti e le dipendenze usate dal PureData.

Per comunicare con la scheda Arduino da PureData occorre installare un oggetto denominato **[comport]**. Nuovamente da terminale si usano i comando:

```
sudo apt-get install pd-comport
```

### fase 3 - primi test 

A questo punto si può pensare di realizzare un semplice circuito e scrivere un corrispondente sketch in Arduino, così che la scheda registri informazioni dal mondo fisico e sia pronta ad inviarle a PureData.

Ecco il semplice circuito che utilizzeremo:

![serial](/assets/Fritzing_imgs/testSerial_bb.png){: width="100%"}

In questo modo potremmo leggere:

* valori analogici dal potenziometro;
* valori digitali dal pushbutton;

e allo stesso tempo accende o spegnere un LED ascoltando i messaggi in arrivo da PureData tramite comunicazione seriale.

Lo sketch di Arduino è quello mostrato qui di seguito e scaricabile dal [repository](https://github.com/Limulo/pccc-sae2016) del corso:

``` C
#define LED 13
#define BUTTON 7
#define POT A0

/* addresses */
#define POT_ADDR 0
#define BUTT_ADDR 1

boolean bSendSerial = false;
boolean bLedStatus = false;
byte lastAddress = 0;

// SETUP ////////////////////////
void setup() 
{
  Serial.begin( 9600, SERIAL_8N1 );
  pinMode(LED, OUTPUT);
  pinMode(BUTTON, INPUT);
  digitalWrite(LED, bLedStatus);
}

// LOOP /////////////////////////
void loop() 
{  
  int value = -1;

  value = analogRead(POT);
  if(bSendSerial)
  {
    Serial.write(128 + POT_ADDR);
    Serial.write(value>>3); //divisione per 8
  }

  value = digitalRead(BUTTON);
  if(bSendSerial)
  {
    Serial.write(128 + BUTT_ADDR);
    Serial.write(value);
  }

  digitalWrite(LED, bLedStatus);

  delay(100);
}


// SERIAL EVENT /////////////////
void serialEvent()
{
  byte b = Serial.read();
  
  if(b>127)
    lastAddress = b;
  else
  {
    switch(lastAddress)
    {
      case 255:
        if (b == 1)
          bSendSerial = true;
        else
          bSendSerial = false;
        break;
      case 240:
        if (b == 1)
          bLedStatus = true;
        else
          bLedStatus = false;
        break; 
      default:
        //...//
        break;
   }
 }   
}
```

Una variabile _booleana_ **bSendSerial** abilita o disabilità l'invio da parte di Arduino dei dati associati ai sensori.
Tale varaibile viene settata nella funzione _serialEvent_ la quale è invocata ogni volta che un nuov byte è in attesa sul buffer seriale di Arduino (in altre parole per ogni byte che PureData invia alla scheda Arduino).

Infatti sarà compito di PureData informare Arduino d'essere pronto per ricevere i dati dai sensori inviando un messaggio appositamente formattato. Lo stesso tipo di formato sarà poi usato da Arduino per inviare i dati dei sensori così che, lato PureData, sia possibile discriminare quali dati siano associati a ciascun sensore.

## protocollo di comunicazione

L'unità base dei dati che saranno inviati via USB è il **byte**. Sappiamo che con un byte possiamo rappresentare valori numerici da 0 a 255. 

Allo stesso tempo dobbiamo però risolvere 2 problemi di natura differente:

* come fare ad inviare via USB informazioni che descrivano sia il dato associato al sensore sia il suo identificativo numerico (_indirizzo_) così da essere sempre in grado di sapere quali dati corrispondano a quali sensori?
* taluni sensori ritornano valori numeri compresi tra 0 e 1023, quantità non rappresentabili con un singolo byte.

Per ovviare al primo problema stabiliamo che tutti i valori numerici ricevuti da PureData il cui valore sia superiore a 127 rappresentino degli indirizzi, mentre tutti quelli i valori minori di 128 identificano il dato vero e proprio. In questo modo, facendo uso di un singolo byte possiamo inviare sia indirizzi che letture.

Per far fronte al secondo problema invece è sufficiente scalare il valore grezzo iniziale per un fattore opportuno tale da costringerlo in un range più limitato
```
1024 / 8 = 128
```

 Nel ciclo _loop_ vengono effettuate letture sia dal potenziometro che dal pulsante. Eventualmente queste vengono poi comunicate via seriale sottoforma dei 2 byte `indirizzo` + `valore`. Il _loop_continua con la scirttura digitale sul pin 13 per illuminare o spegnere il LED comandato questo da PureData.




### Approfondimenti


### Tra le altre cose...
... abbiamo anche parlato di:

